namespace protocol;

union MessageBody {
    // Compile time:
    // Requests are sent by pyprob/NN
    // Replies are sent by CPProb/Anglican
    RequestTraces,
    ReplyTraces,
    RequestFinishCompilation,
    ReplyFinishCompilation,
    // Inference time:
    // Requests are sent by CPProb/Anglican
    // Replies are sent by pyprob/NN
    RequestStartInference,
    ReplyStartInference,
    RequestFinishInference,
    ReplyFinishInference,
    RequestProposal,
    ReplyProposal
}

table Message {
    body: MessageBody;
}

union Distribution {
    Beta,
    Discrete,
    Flip,
    Gamma,
    Laplace,
    Mixture,
    MultivariateNormal,
    Normal,
    Poisson,
    Truncated,
    UniformContinuous,
    UniformDiscrete
}

table Tensor {
    data: [double];
    shape: [int];
}

table Sample {
    address: string;
    distribution: Distribution;
    value: Tensor;
}

table Trace {
    observations: Tensor;
    samples: [Sample];
}

table Beta { // value: double; [0, 1]
    shape_a: double; // R^+
    shape_b: double; // R^+
}

table Discrete { // value: [min, max]
    min: int;    // Z
    max: int;    // Z
    probabilities: Tensor; // \sum probabilities = 1, probabilities >= 0, size(probabilities) = max - min + 1
}

table Flip { // value: int; {0, 1}
    probability: double; // [0, 1]
}

table Gamma {      // value: double; R^+
    shape: double; // (alpha) R^+
    rate:  double; // (beta)  R^+
}

table Laplace {       // value: double; R
    location: double; // R
    scale:    double; // R^+
}

table MultivariateNormal { // value: Tensor; R^n
    mean: Tensor;          // R^n
    covariance: Tensor;    // If n = 1: diagonal of covariance matrix; if n = 2: full covariance matrix
}

table Normal {    // value: double; R
    mean: double; // R
    std:  double; // R^+
}

table Poisson {   // value: int; N
    rate: double; // (lambda) R^+
}

table UniformContinuous { // value: double; [min, max]
    min: double; // R
    max: double; // R
}

table UniformDiscrete { // value: int; {min, ..., max}
    min: int; // N
    max: int; // N
}

// Hack to get over the fact that Flatbuffers odes not supports lists of unions
// https://github.com/google/flatbuffers/issues/3838
// Error: Vector of unions are not yet supported in Flatbuffers python
table NestedDistribution {
    distribution: Distribution;
}

table Mixture { // size(coefficients) == size(distributions)
    coefficients: [double]; // \sum coefficients = 1, coefficients >= 0
    distributions: [NestedDistribution];
}

table ProductDistribution {
    distributions: [NestedDistribution];
    shape: [int];
}

table Truncated {
    min: double; // R
    max: double; // R
    distribution: NestedDistribution;
}

// Messages
// Compile time:
// Requests are sent by pyprob/NN
// Replies are sent by CPProb/Anglican
table RequestTraces {
    num_traces: int;
}
table ReplyTraces {
    traces: [Trace];
}

table RequestFinishCompilation { }
table ReplyFinishCompilation { }

// Inference time:
// Requests are sent by CPProb/Anglican
// Replies are sent by pyprob/NN
table RequestStartInference {
    observation: Tensor;
}
table ReplyStartInference {}

table RequestFinishInference {}
table ReplyFinishInference {}

table RequestProposal {
    current_sample: Sample;
    previous_sample: Sample;
}
table ReplyProposal {
    distribution: Distribution;
}

root_type Message;
file_identifier "INFC";
